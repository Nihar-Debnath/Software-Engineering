![](./images/Prototyping-model.png)

# 📌 **Prototyping Model in Software Engineering**

The **Prototyping Model** is an SDLC model in which a **prototype (an early working version of the software)** is built, tested, and refined repeatedly until the final system is accepted.

👉 In simple words: Instead of building the final product in one go (like in Waterfall), we first make a **rough working model** of the system, get **feedback from users**, and then improve it step by step.

---

## 🔄 **Process of Prototyping Model**

1. **Requirement Gathering**

   * Collect initial requirements from the customer.
   * Not all requirements are clear at the start.

2. **Quick Design**

   * Create a rough design focusing only on key features.

3. **Build Prototype**

   * Develop a simple working model (mock-up).

4. **User Evaluation**

   * Customer uses the prototype and gives feedback.

5. **Refinement**

   * Requirements are adjusted and prototype is improved.

6. **Final Product Development**

   * Once requirements are clear, the actual system is built.

---

## ✅ **Advantages**

* Helps when requirements are unclear or not well-defined.
* Users can **see and interact** with the system early.
* Reduces risk of failure because users give feedback continuously.
* Errors and missing requirements can be detected early.

---

## ❌ **Disadvantages**

* Building multiple prototypes can be **time-consuming** and **costly**.
* Users may mistake the prototype for the final product (expecting quick delivery).
* If not controlled, frequent changes can cause **scope creep** (endless modifications).
* Not suitable for very large, complex, or performance-critical systems.

---

## 📊 **Best Used When**

* Requirements are not clear from the beginning.
* User involvement and feedback are important.
* Interfaces and user experience are critical (e.g., websites, apps, UI-heavy software).

---

## ✨ Types of Prototyping

1. **Throwaway / Rapid Prototyping** → Prototype is built quickly, then discarded after requirements are clear.
2. **Evolutionary Prototyping** → Prototype is improved continuously until it becomes the final system.
3. **Incremental Prototyping** → System is built in parts (modules), each as a prototype, then combined.
4. **Extreme Prototyping (for Web Apps)** → First build mock UI, then functional services, then integrate.

---

👉 In short:
The **Prototyping Model** is a **“build-test-refine”** approach that helps clarify requirements through **early working models** and **user feedback**.
